<section id="algorithms">
    <h2>Algorithms</h2>

    <h3>Wallet address request</h3>
    <p>The send a wallet address request, refer to the <a data-cite="opwa/operations/get-wallet-address#">Open Payments get wallet address request</a>.</p>
    <div class="algorithm">
        When asked to <dfn>send a wallet address request</dfn>, given a <var data-type="DOMString">walletAddress</var> perform the following steps.
        <ol>
            <li>
                Let <var>walletAddressUrl</var> be the result of running [=URL parser=] with <var>walletAddress</var>.
            </li>
            <li>
                If <var>walletAddressUrl</var> [=url/scheme=] is not `https`, return failure.
            </li>
            <li>
                <p>Let <var>request</var> be a new [=request=] as follows:</p>
                <dl>
                    <dt>[=request/url=]</dt>
                    <dd><var>walletAddressUrl</var></dd>
                    <dt>[=request/method=]</dt>
                    <dd>"GET"</dd>
                    <dt>[=request/body=]</dt>
                    <dd>null</dd>
                    <dt>[=request/redirect mode=]</dt>
                    <dd>"follow"</dd>
                    <dt>[=request/client=]</dt>
                    <dd>null</dd>
                    <dt>[=request/window=]</dt>
                    <dd>"no-window"</dd>
                    <dt>[=request/service-workers mode=]</dt>
                    <dd>"none"</dd>
                    <dt>[=request/destination=]</dt>
                    <dd>"monetization"</dd>
                    <dt>[=request/header list=]</dt>
                    <dd>"a list containing a single header with name set to Accept and value set to `application/json`.</dd>
                    <dt>[=request/mode=]</dt>
                    <dd>"cors"</dd>
                </dl>
            </li>
            <li>
                Let <var>details</var> be null.
            </li>
            <li>
                Perform a [=fetch request=] with <var>request</var> and with <var>processResponseConsumeBody</var> set to the following steps, given a <a href="https://fetch.spec.whatwg.org/#concept-response">response</a> and <var>response</var>'s [=request/body=] <var>responseBody</var>:
                <ol>
                    <li>
                        Let <var>json</var> be the result of [=extract the JSON fetch response=] from <var>response</var> and <var>responseBody</var>.
                    </li>
                    <li>
                        Convert <var>json</var> to a {{ WalletAddressDetails }}, <var>walletAddressDetails</var>. 
                    </li>
                    <li>
                        If one of the previous two steps threw an exception, return failure.
                    </li>
                    <li>
                        Set <var>details</var> to <var>walletAddressDetails</var>.
                    </li>
                </ol>
            </li>
            <li>
                Return <var>details</var>.
            </li>
        </ol>
    </div>
    <pre class="idl">
        dictionary WalletAddressDetails {
            required DOMString id;
            DOMString publicName;
            required DOMString authServer;
            required DOMString resourceServer;
            required DOMString assetCode;
            required unsigned short assetScale;
        };
    </pre>

    <h3>Outgoing payment and quote grant request</h3>
    <p>The send an outgoing payment and quote grant requests refers to the <a data-cite="opas/operations/post-continue#">Open Payments grant request</a></p>
    <div class="algorithm">
        When asked to <dfn>send an outgoing payment and quote grant request</dfn>, given <a><var>walletAddressDetails</var></a>, <var data-type="number">budget</var> and <var data-type="boolean">renewMonthly</var> perform the following steps.
        <ol>
            <li>
                Let <var>authServer</var> be the result of running [=URL parser=] with <var>walletAddressDetails</var>'s `authServer` property.
            </li>
            <li>
                If walletAddressUrl [=url/scheme=] is not `https`, return failure. 
            </li>
            <li>
                Let <var>requestBody</var> be the result of running a JSON serialization on:
            </li>
            <li>
                <p>Let <var>request</var> be a new [=request=] as follows:</p>
                <dl>
                    <dt>[=request/url=]</dt>
                    <dd><var>authServer</var>
                    <dt>[=request/method=]</dt>
                    <dd>"POST"</dd>
                    <dt>[=request/body=]</dt>
                    <dd>the result of running JSON serialization on a {{ GrantRequest }}</dd>
                    <dt>[=request/redirect mode=]</dt>
                    <dd>"follow"</dd>
                    <dt>[=request/client=]</dt>
                    <dd>null</dd>
                    <dt>[=request/window=]</dt>
                    <dd>"no-window"</dd>
                    <dt>[=request/service-workers mode=]</dt>
                    <dd>"none"</dd>
                    <dt>[=request/destination=]</dt>
                    <dd>"monetization"</dd>
                    <dt>[=request/header list=]</dt>
                    <dd>a list containing a single header with name set to `Content-Type` and value set to `application/json`.</dd>
                    <dt>[=request/mode=]</dt>
                    <dd>"cors"</dd>
                </dl>
            </li>
            <li>
                Run the [=generate an HTTP message signature=] algorithm on the <var>request</var>.
            </li>
            <li>
                Let <var>grant</var> be null.
            </li>
            <li>
                Perform a [=fetch request=] with <var>request</var> and with <var>processResponseConsumeBody</var> set to the following steps, given a <a href="https://fetch.spec.whatwg.org/#concept-response">response</a> and <var>response</var>'s [=request/body=] <var>responseBody</var>:
                <ol>
                    <li>
                        Let <var>json</var> be the result of [=extract the JSON fetch response=] from <var>response</var> and <var>responseBody</var>.
                    </li>
                    <li>
                        Convert <var>json</var> to a {{ PendingGrant }}, <var>grantResponse</var>. 
                    </li>
                    <li>
                        If one of the previous two steps threw an exception, return failure.
                    </li>
                    <li>
                        Set <var>grant</var> to <var>grantResponse</var>.
                    </li>
                </ol>
            </li>
        </ol>
        <aside class="example" title="Grant request JSON payload">
            <pre class="json">
            {
                "access_token": {
                    "access": [
                        {
                            "type": "quote",
                            "actions": ["create"]
                        },
                        {
                            "type": "outgoing-payment",
                            "actions": ["create", "read"],
                            "identifier": "https://wallet.example/user",
                            "limits": {
                                identifier: "https://wallet.example/user",
                                "debitAmount": {
                                    "value": "1500",
                                    "assetScale": 2, // wallet address asset scale
                                    "assetCode": "USD" // wallet address assset code
                                }
                            }
                        }
                    ]
                },
                "client": "https://wallet.example/user"
                "interact": {
                    "start": ["redirect"]
                },
            }
            </pre>
        </aside>
        <aside class="example" title="Pending grant response JSON payload">
            <pre class="json">
            {
                "interact": {
                    "redirect": "https://auth.wallet.example/4CF492MLVMSW9MKMXKHQ",
                    "finish": "4105340a-05eb-4290-8739-f9e2b463bfa7"
                },
                "continue": {
                    "access_token": {
                        "value": "33OMUKMKSKU80UPRY5NM"
                    },
                    "uri": "https://auth.wallet.example/continue/4CF492MLVMSW9MKMXKHQ",
                    "wait": 30
                }
            }
            </pre>
        </aside>
    </div>

    <h3>Continue grant request</h3>
    <p>The send a continue grant request, refers to the <a data-cite="opas/operations/post-continue#">Open Payments grant request</a></p>
    <div class="algorithm">
        When asked to <dfn>send a continue grant request</dfn>, given <var>continueUri</var>, <var>accessToken</var> perform the following steps.
        <ol>
            <li>
                Let <var>uri</var> be the result of running [=URL parser=] with <var>continueUri</var>.
            </li>
            <li>
                If <var>uri</var> [=url/scheme=] is not `https`, return failure. 
            </li>
            <li>
                <p>Let <var>request</var> be a new [=request=] as follows:</p>
                <dl>
                    <dt>[=request/url=]</dt>
                    <dd><var>uri</var>
                    <dt>[=request/method=]</dt>
                    <dd>"POST"</dd>
                    <dt>[=request/body=]</dt>
                    <dd>"none"</dd>
                    <dt>[=request/redirect mode=]</dt>
                    <dd>"follow"</dd>
                    <dt>[=request/client=]</dt>
                    <dd>null</dd>
                    <dt>[=request/window=]</dt>
                    <dd>"no-window"</dd>
                    <dt>[=request/service-workers mode=]</dt>
                    <dd>"none"</dd>
                    <dt>[=request/destination=]</dt>
                    <dd>"monetization"</dd>
                    <dt>[=request/header list=]</dt>
                    <dd>a list containing a single header with name set to `Content-Type` and value set to `application/json`.</dd>
                    <dt>[=request/mode=]</dt>
                    <dd>"cors"</dd>
                </dl>
            </li>
            <li>
                Run the [=generate an HTTP message signature=] algorithm on the <var>request</var>.
            </li>
            <li>
                Let <var>grant</var> be null.
            </li>
            <li>
                Perform a [=fetch request=] with <var>request</var> and with <var>processResponseConsumeBody</var> set to the following steps, given a [=response=] and <var>response</var>'s [=request/body=] <var>responseBody</var>:
                <ol>
                    <li>
                        Let <var>json</var> be the result of [=extract the JSON fetch response=] from <var>response</var> and <var>responseBody</var>.
                    </li>
                    <li>
                        Convert <var>json</var> to a {{ PendingGrant }} or {{ Grant }}, <var>grantResponse</var>. 
                        <p class="note">
                            The continuation request can return a {{ PendingGrant }} or a {{ Grant }}.
                        </p>
                    </li>
                    <li>
                        If one of the previous two steps threw an exception, return failure.
                    </li>
                    <li>
                        Set <var>grant</var> to <var>grantResponse</var>.
                    </li>
                </ol>
            </li>
            <li>
                Return <var>grant</var>.
            </li>
        </ol>
    </div>

    <h3>Cancel grant request</h3>
    <p>The cancel grant request, refers to the <a data-cite="opas/operations/delete-continue#">Open Payments cancel grant request</a>.</p>
    <div class="algorithm">
        When asked to <dfn>send a cancel grant request</dfn>, given <var>continueUri</var>, <var>accessToken</var> perform the following steps.
        <ol>
            <li>
                Let <var>uri</var> be the result of running [=URL parser=] with <var>continueUri</var>.
            </li>
            <li>
                If <var>uri</var> [=url/scheme=] is not `https`, return failure. 
            </li>
            <li>
                <p>Let <var>request</var> be a new [=request=] as follows:</p>
                <dl>
                    <dt>[=request/url=]</dt>
                    <dd><var>uri</var></dd>
                    <dt>[=request/method=]</dt>
                    <dd>"DELETE"</dd>
                    <dt>[=request/body=]</dt>
                    <dd>"none"</dd>
                    <dt>[=request/redirect mode=]</dt>
                    <dd>"follow"</dd>
                    <dt>[=request/client=]</dt>
                    <dd>null</dd>
                    <dt>[=request/window=]</dt>
                    <dd>"no-window"</dd>
                    <dt>[=request/service-workers mode=]</dt>
                    <dd>"none"</dd>
                    <dt>[=request/destination=]</dt>
                    <dd>"monetization"</dd>
                    <dt>[=request/header list=]</dt>
                    <dd>a list containing a single header with name set to `Content-Type` and value set to `application/json`.</dd>
                    <dt>[=request/mode=]</dt>
                    <dd>"cors"</dd>
                </dl>
            </li>
            <li>
                Run the [=generate an HTTP message signature=] algorithm on the <var>request</var>.
            </li>
            <li>
                Perform a [=fetch request=] with <var>request</var>, given a [=response=]:
                <ol>
                    <li>
                        If {{"NetworkError"}} is thrown, notify the user that the browser could not cancel the grant.
                    </li>
                    <li>
                        If the [=status=] is `204`, the grant was successfully canceled and the storage can be cleared.
                        <p class="note">
                            When clearing the storage all user data should be removed. The only properties that should not be cleared are: <a href="#dom-storage-privatekey">privateKey</a>, <a href="#dom-storage-publickey">publicKey</a>, <a href="#dom-storage-kid">kid</a>.
                        </p>
                    </li>
                </ol>
            </li>
        </ol>
    </div>

    <h3>Helper algorithms</h3>

    <h4>Fetch request</h4>
    <div class="algorithm">
        To perform a <dfn>fetch request</dfn> given a [=request=] request and an algorithm <var>processResponseConsumeBody</var>, execute the following steps:
        <ol>
            <li>
                [=Queue a global task=] on the [=networking task source=] to [=fetch=] <var>request</var> with [=fetch/processresponseendofbody=] set to <var>processResponseConsumeBody</var>.
            </li>
        </ol>
    </div>

    <h4>Extract JSON from fetch response</h4>
    <div class="algorithm">
        <p>To <dfn>extract the JSON fetch response</dfn> a [=response=] response:
        <ol>
            <li>
                If <var>response</var> is a [=network error=] or its [=status=] is not an [=ok status=], throw a new {{"NetworkError"}}.
            </li>
            <li>
                Let <var>mimeType</var> be the result of [=header list/extract a MIME type=] from <var>response</var>'s [=header list=].
            </li>
            <li>
                If <var>mimeType</var> is failure or is not a [=JSON MIME type=], throw a new {{"NetworkError"}}.
            </li>
            <li>
                Let <var>json</var> be the result of [=parse JSON bytes to an infra value=] passing <var>responseBody</var>.
            </li>
            <li>
                If <var>json</var> is a parsing exception, throw a new {{"NetworkError"}}.
            </li>
            <li>
                Return <var>json</var>.
            </li>
        </ol>
    </div>

    <h4>Generate HTTP Signature</h4>
    <p>Generate an HTTP Message signature, based on <a href="https://datatracker.ietf.org/doc/rfc9421/">RFC 9421 - HTTP Message signatures.</a>
    <p class="note">
        This example is illustrative and aims to show one possible flow. 
    </p>
    <div class="algorithm">
        When asked to <dfn>generate an HTTP message signature</dfn>, given a <var data-type="request">request</var>, perform the following steps:

        <ol>
            <li>Let <var>request</var> to be the given HTTP request to be signed.</li>
            <li>
                If <var>request</var>'s body is not `null`, run the following steps:
                <ol>
                    <li>
                        Let <var>mediaType</var> be the result of [=header list/extract a MIME type=] and [=header list/append=] to <var>request</var>'s headers, `Content-Type` with the value <var>mediaType</var>.
                    </li>
                    <li>
                        Compute a digest of <var>request</var>'s body using the `sha-512` algorithm. Let <var>digestValue</var> be the base64-encoded result of the computation. [=header list/Append=] to <var>request</var>'s headers, `Content-Digest` with the value <var>digestValue</var>.
                    </li>
                    <li>
                        Let <var>length</var> be the length in bytes, of <var>request</var>'s body. [=header list/Append=] to <var>request</var>'s headers,  `Content-Length` with the value <var>length</var>.
                    </li>
                </ol>
            </li> 
            <li>
                Let <var>components</var> be an array of strings identifying which content (headers, etc.) to include in the signature.
                <ol>
                    <li>Let `components` default value be `<<"@method", "@target-uri">>`.</li>
                    <li>If <var>request</var>'s headers includes the `Authorization` header, append `authorization` to <var>components</var>.
                    <li>If <var>request</var>'s body is not `null`, append `content-lenght`, `content-digest` and `content-type` to <var>components</var>.
                </ol>
            </li>
            <li>
                Let <var>algorithm</var> be `ed25519`.
            </li>
            <li>
                Let <var>privateKey</var> be the Ed25519 private key.
            </li>
            <li>
                Construct the canonical data for each element in <var>components</var>.
            </li>
            <li>
                Concatenate the canonical data into a single string (or buffer).
            </li>
            <li>
                Use `Ed25519` to sign the canonical data with <var>privateKey</var>.
            </li>
            <li>
                Let <var>signatureValue</value> be the resulting signature, base64-encoded.
            </li>
            <li>
                Construct the `Signature-Input` header value, including the components, the `algorithm` (`ed25519`), `keyid` and `created` and [=header list/append=] it to <var>request's</var> headers.
                <div class="note">
                    <p>`keyid` represents the key identifier - <a href="#key-id">Key ID</a>.</p>
                    <p>`created` represents the creation time of the signature as a UNIX timestamp value of type Integer. Sub-second precision is not supported.</p>
                </div>
            </li>
            <li>
                [=header list/Append=] to <var>request</var>'s headers, `Signature` with the value <var>signatureValue</var>.
            </li>
        </ol>
        <aside class="example" title="Signature base">
            <pre>
                "content-type": application/json
                "content-digest": sha-512=:X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:
                "content-length": 18
                "authorization": GNAP 123454321
                "@method": POST
                "@target-uri": https://example.com/
                "@signature-params": ("content-type" "content-digest" "content-length" "authorization" "@method" "@target-uri");alg="ed25519";keyid="eddsa_key_1";created=1704722601
            </pre>
        </aside>
        <aside class="example" title="Signed message">
            <pre>
                POST HTTP/1.1
                Host: https://example.com
                Content-Type: application/json
                Content-Length: 18
                Authorization: "GNAP 123454321"
                Signature-Input: sig1=("content-type" "content-digest" "content-length" "authorization" "@method" "@target-uri");alg="ed25519";keyid="eddsa_key_1";created=1704722601
                Signature: sig1=:EiCdZMbyXj6pN59g+mh3mY/Q6DlSBrCL7CJM4OZ550+d2MZhfdDKrOJU/ugeRdwd1KYyd1wA/VA7J2fi9YehCA==:
                
                {
                    "hello":"world"
                }
            </pre>
        </aside>
    </div>
</section>
